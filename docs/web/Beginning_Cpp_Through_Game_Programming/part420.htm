<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>The Deck Class</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part419.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part421.htm">Next &gt;</a></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: justify;"><h1 href="#bookmark13">The Deck Class</h1></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">The <span class="s35">Deck </span>class represents a deck of cards. It<span class="s12">’</span>s derived from <span class="s35">Hand</span>.</p><p class="s35" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">class Deck : public Hand</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s19" style="padding-top: 2pt;padding-left: 281pt;text-indent: 0pt;text-align: left;">Introducing the Blackjack Game 371</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">public:</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">Deck();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;text-align: left;">virtual ~Deck();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;line-height: 118%;text-align: left;">//create a standard deck of 52 cards void Populate();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;line-height: 118%;text-align: left;">//shuffle cards void Shuffle();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;line-height: 119%;text-align: left;">//deal one card to a hand void Deal(Hand&amp; aHand);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-top: 3pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">//give additional cards to a generic player</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">void AdditionalCards(GenericPlayer&amp; aGenericPlayer);</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Deck::Deck()</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;line-height: 119%;text-align: left;">m_Cards.reserve(52); Populate();</p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Deck::~Deck()</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">void Deck::Populate()</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">Clear();</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">//create standard deck</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">for (int s = Card::CLUBS; s &lt;= Card::SPADES; ++s)</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">for (int r = Card::ACE; r &lt;= Card::KING; ++r)</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">Add(new Card(static_cast&lt;Card::rank&gt;(r),</p><p class="s35" style="padding-top: 2pt;padding-left: 170pt;text-indent: 0pt;text-align: left;">static_cast&lt;Card::suit&gt;(s)));</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 61pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">void Deck::Shuffle()</p><p class="s19" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark1214">372 Chapter 10 </a><span class="s32">n </span>Inheritance and Polymorphism: Blackjack</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">random_shuffle(m_Cards.begin(), m_Cards.end());</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">void Deck::Deal(Hand&amp; aHand)</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">if (!m_Cards.empty())</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;line-height: 118%;text-align: left;">aHand.Add(m_Cards.back()); m_Cards.pop_back();</p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">else</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">cout &lt;&lt; &quot;Out of cards. Unable to deal.&quot;;</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">void Deck::AdditionalCards(GenericPlayer&amp; aGenericPlayer)</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">cout &lt;&lt; endl;</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">//continue to deal a card as long as generic player isn’t busted and</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">//wants another hit</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">while ( !(aGenericPlayer.IsBusted()) &amp;&amp; aGenericPlayer.IsHitting() )</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">Deal(aGenericPlayer);</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">cout &lt;&lt; aGenericPlayer &lt;&lt; endl;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">if (aGenericPlayer.IsBusted())</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">aGenericPlayer.Bust();</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s24" style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Hi n t</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="517" height="1" alt="image" src="Image_458.png"/></span></p><p class="s19" style="padding-top: 6pt;padding-left: 59pt;text-indent: 0pt;text-align: justify;"><i>Type casting </i>is a way of converting a value of one type to a value of another type. One way to do type casting is to use <span class="s35">static_cast</span>. You use <span class="s35">static_cast </span>to return a value of a new type from a value of another type by specifying the new type you want between <span class="s35">&lt; </span>and <span class="s35">&gt;</span>, followed by the value from which you want to get a new value between parentheses. Here’s an example that returns the double value 5.0.</p><p class="s35" style="padding-top: 5pt;padding-bottom: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">static_cast&lt;double&gt;(5);</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="490" height="3" alt="image" src="Image_459.png"/></span></p><p class="s19" style="padding-top: 2pt;padding-left: 281pt;text-indent: 0pt;text-align: left;"><a name="bookmark1215">Introducing the Blackjack Game 373</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Populate() <span class="p">creates a standard deck of 52 cards. The member function loops through all of the possible combinations of </span>Card::suit <span class="p">and </span>Card::rank <span class="p">values. It uses </span>static_cast <span class="p">to cast the </span>int <span class="p">loop variables to the proper enumerated types defined in </span>Card<span class="p">.</span></p><p class="s35" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Shuffle() <span class="p">shuffles the cards in the deck. It randomly rearranges the pointers in </span>m_Cards <span class="p">with </span>random_shuffle() <span class="p">from the Standard Template Library. This is the reason I include the </span>&lt;algorithm&gt; <span class="p">header file.</span></p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;"><a name="bookmark1137"><span class="s35">Deal() </span></a>deals one card from the deck to a hand. It adds a copy of the pointer to the back of <span class="s35">m_Cards </span>to the object through the object<span class="s12">’</span>s <span class="s35">Add() </span>member function. Then, it removes the pointer at the back of <span class="s35">m_Cards</span>, effectively transferring the card. The powerful thing about <span class="s35">Deal() </span>is that it accepts a reference to a <span class="s35">Hand </span>object, which means it can work equally well with a <span class="s35">Player </span>or a <span class="s35">House </span>object. And through the magic of polymorphism, <span class="s35">Deal() </span>can call the object<span class="s12">’</span>s <span class="s35">Add() </span>member function without knowing the exact object type.<a name="bookmark1216">&zwnj;</a></p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;"><span class="s35">AdditionalCards() </span>gives additional cards to a generic player until the generic player either stops hitting or busts. The member function accepts reference to a <span class="s35">GenericPlayer </span>object so you can pass a <span class="s35">Player </span>or <span class="s35">House </span>object to it. Again, through the magic of polymorphism, <span class="s35">AdditionalCards() </span>doesn<span class="s12">’</span>t have to know whether it<span class="s12">’</span>s working with a <span class="s35">Player </span>or a <span class="s35">House </span>object. It can call the <span class="s35">IsBusted() </span>and <span class="s35">IsHitting() </span>member functions for the object without knowing the object<span class="s12">’</span>s type, and the correct code will be executed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part419.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part421.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
