<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Declaring and Defining Copy Constructors</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part372.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part374.htm">Next &gt;</a></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"><a href="part3.htm#bookmark12" class="h1">Declaring and Defining Copy </a><h1 href="#bookmark12">Constructors</h1></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Sometimes an object is copied automatically for you. This occurs when an object is:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s29" style="padding-top: 2pt;padding-left: 53pt;text-indent: 0pt;text-align: left;">n <span class="p">Passed by value to a function</span></p><p class="s29" style="padding-top: 5pt;padding-left: 53pt;text-indent: 0pt;text-align: left;">n <span class="p">Returned from a function</span></p><p class="s29" style="padding-top: 5pt;padding-left: 53pt;text-indent: 0pt;text-align: left;">n <span class="p">Initialized to another object through an initializer</span></p><p style="padding-top: 5pt;padding-left: 53pt;text-indent: 0pt;text-align: left;"><span class="s29">n </span>Provided as a single argument to the object<span class="s12">’</span>s constructor</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">The copying is done by a special member function called the <span class="s11">copy constructor</span>. Like constructors and destructors, a default copy constructor is supplied for you if you don<span class="s12">’</span>t write one of your own. The default copy constructor simply copies the value of each data member to data members of the same name in the new object<span class="s12">—</span>a <span class="s11">member-wise copy</span>.</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">For simple classes, the default copy constructor is usually fine. However, when you have a class with a data member that points to a value on the heap, you should consider writing your own copy constructor. Why? Imagine a <span class="s35">Critter </span>object that has a data member that<span class="s12">’</span>s a pointer to a <span class="s35">string </span>object on the heap. With only a default copy constructor, the automatic copying of the object would result in a new object that points to the same single <span class="s35">string </span>on the heap because the pointer of the new object would simply get a copy of the address stored in</p><p class="s19" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark1076">310 Chapter 9 </a><span class="s32">n </span>Advanced Classes and Dynamic Memory: Game Lobby</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">the pointer of the original object. This member-wise copying produces a <span class="s11">shallow copy</span>, in which the pointer data members of the copy point to the same chunks of memory as the pointer data members in the original object.</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Let me give you a specific example. If I hadn<span class="s12">’</span>t written my own copy constructor in the Heap Data Member program, when I passed a <span class="s35">Critter </span>object by value with the following function call, the program would have automatically made a shallow copy of <span class="s35">crit </span>called <span class="s35">aCopy </span>that existed in <span class="s35">testCopyConstructor()</span>.</p><p class="s35" style="padding-top: 5pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">testCopyConstructor(crit);</p><p class="s35" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">aCopy<span class="s12">’</span><span class="p">s </span>m_pName <span class="p">data member would point to the exact same </span>string <span class="p">object on the heap as </span>crit<span class="s12">’</span><span class="p">s </span>m_pName <span class="p">data member does. Figure 9.8 shows you what I mean. Note that the image is abstract since the name of the critter is actually stored as a </span>string <span class="p">object, not a string literal.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 7pt;text-align: left;"><span><img width="17" height="10" alt="image" src="Image_357.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"><span><img width="284" height="114" alt="image" src="Image_358.png"/></span></p><p class="s37" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Figure 9.8</p><p class="s19" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">If a shallow copy of <span class="s35">crit </span>were made, both <span class="s35">aCopy </span>and <span class="s35">crit </span>would have a data member that points to the same chunk of memory on the heap.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Why is this a problem? Once <span class="s35">testCopyConstructor() </span>ends, <span class="s35">aCopy</span><span class="s12">’</span>s destructor is called, freeing the memory on the heap pointed to by <span class="s35">aCopy</span><span class="s12">’</span>s <span class="s35">m_pName </span>data member. Because of this, <span class="s35">crit</span><span class="s12">’</span>s <span class="s35">m_pName </span>data member would point to memory that has been freed, which would mean that <span class="s35">crit</span><span class="s12">’</span>s <span class="s35">m_pName </span>data member would be a dangling pointer! Figure 9.9 provides you with a visual representation of this. Note that the image is abstract since the name of the critter is actually stored as a <span class="s35">string </span>object, not a string literal.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">What you really need is a copy constructor that produces a new object with its own chunk of memory on the heap for each data member that points to a heap object<span class="s12">—</span>a <span class="s11">deep copy</span>. That<span class="s12">’</span>s what I do when I define a copy constructor for the</p><p class="s19" style="padding-top: 2pt;padding-left: 225pt;text-indent: 0pt;text-align: left;">Working with Data Members and the Heap 311</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 89pt;text-indent: 0pt;line-height: 7pt;text-align: left;"><span><img width="17" height="10" alt="image" src="Image_359.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 39pt;text-indent: 0pt;text-align: left;"><span><img width="285" height="115" alt="image" src="Image_360.png"/></span></p><p class="s37" style="padding-top: 5pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">Figure 9.9</p><p class="s19" style="padding-left: 39pt;text-indent: 0pt;text-align: left;">If the shallow copy of the <span class="s35">Critter </span>object were destroyed, the memory on the heap that it shared with the original object would be freed. As a result, the original object would have a dangling pointer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: left;">class, which replaces the default one provided by the compiler. First, inside the class definition, I declare the copy constructor:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;text-align: left;">Critter(const Critter&amp; c); //copy constructor prototype</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Next, outside the class definition, I define the copy constructor:</p><p class="s35" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Critter::Critter(const Critter&amp; c) //copy constructor definition</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;line-height: 119%;text-align: justify;">cout &lt;&lt; &quot;Copy Constructor called\n&quot;; m_pName = new string(*(c.m_pName)); m_Age = c.m_Age;</p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Just like this one, a copy constructor must have the same name as the class. It returns no value, but accepts a reference to an object of the class<span class="s12">—</span>the object that needs to be copied. The reference should be made a constant reference to protect the original object from being changed during the copy process.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">The job of a copy constructor is to copy any data members from the original object to the copy object. If a data member of the original object is a pointer to a value on the heap, the copy constructor should request memory from the heap, copy the original heap value to this new chunk of memory, and then point the appropriate copy object data member to this new memory.</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">When I call <span class="s35">testCopyConstructor() </span>by passing <span class="s35">crit </span>to the function by value, the copy constructor  I wrote  is  automatically called.  You  can  tell  this  because  the text  <span class="s35">Copy  Constructor  called.  </span>appears  on  the  screen.  My  copy  constructor creates a new <span class="s35">Critter </span>object (the copy) and accepts a reference to the original in <span class="s35">c</span>.</p><p class="s19" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">312 Chapter 9 <span class="s32">n </span>Advanced Classes and Dynamic Memory: Game Lobby</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">With the line <span class="s35">m_pName = new string(*(c.m_pName));</span>, my copy constructor allocates a new chunk of memory on the heap, gets a copy of the <span class="s35">string </span>pointed to by the original object, copies it to the new memory, and points the <span class="s35">m_pName </span>data member of the copy to this memory. The next line, <span class="s35">m_Age = c.m_Age; </span>simply copies the value of the original<span class="s12">’</span>s <span class="s35">m_Age </span>to the copy<span class="s12">’</span>s <span class="s35">m_Age </span>data member. As a result, a deep copy of <span class="s35">crit </span>is made, and that<span class="s12">’</span>s what gets used in <span class="s35">testCopyConstructor() </span>as <span class="s35">aCopy</span>.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">You  can  see  that  the  copy  constructor  worked  when  I  called  <span class="s35">aCopy</span><span class="s12">’</span>s  <span class="s35">Greet() </span>member function. In my sample run, the member function displayed a message, part  of  which  was  <span class="s35">I’m  Poochie and  I’m  5  years old.  </span>This  part  of  the  message shows that <span class="s35">aCopy </span>correctly got a copy of the values of the data members from the object <span class="s35">crit</span>. The second part of the message, <span class="s35">&amp;m_pName: 73F2ED48003AF660</span>, shows that the string object pointed to by the data member <span class="s35">m_pName </span>of <span class="s35">aCopy </span>is stored in a different chunk of memory than the string pointed to by the data member <span class="s35">m_pName </span>of <span class="s35">crit</span>, which is stored at memory location <span class="s35">73F2ED48003AF78C</span>, proving that a deep copy was made. Remember that the memory addresses displayed in my sample run may be different from the ones displayed when the program is run again. However, the key here is that the addresses stored in <span class="s35">crit</span><span class="s12">’</span>s <span class="s35">m_pName </span>and <span class="s35">aCopy</span><span class="s12">’</span>s <span class="s35">m_pName  </span>are different from each other.</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">When <span class="s35">testCopyConstructor() </span>ends, the copy of the <span class="s35">Critter </span>object used in the function, stored in the variable <span class="s35">aCopy</span>, is destroyed. The destructor frees the chunk of memory on the heap associated with the copy, leaving the original <span class="s35">Critter </span>object, <span class="s35">crit</span>, created in <span class="s35">main()</span>, unaffected. Figure 9.10 shows the results. Note that the image is abstract since the name of the critter is actually stored as a <span class="s35">string </span>object, not a string literal.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 7pt;text-align: left;"><span><img width="17" height="10" alt="image" src="Image_361.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><span><img width="59" height="12" alt="image" src="Image_362.png"/></span> <span><img width="217" height="40" alt="image" src="Image_363.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><span><img width="286" height="58" alt="image" src="Image_364.png"/></span></p><p class="s37" style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Figure 9.10</p><p class="s19" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">With a proper copy constructor, the original and the copy each point to their own chunk of memory on the heap. Then, when the copy is destroyed, the original is unaffected.</p><p class="s19" style="padding-top: 2pt;padding-left: 225pt;text-indent: 0pt;text-align: left;"><a name="bookmark1024">Working with Data Members and the Heap 313</a><a name="bookmark1077">&zwnj;</a><a name="bookmark1078">&zwnj;</a><a name="bookmark1079">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s24" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Hin t</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="519" height="1" alt="image" src="Image_365.png"/></span></p><p class="s19" style="padding-top: 5pt;padding-bottom: 3pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">When you have a class with data members that point to memory on the heap, you should consider writing a copy constructor that allocates memory for a new object and creates a deep copy.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="492" height="3" alt="image" src="Image_366.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part372.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part374.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
