<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Using Base Class Pointers to Derived Class Objects</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part405.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part407.htm">Next &gt;</a></p><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;"><h1 href="#bookmark12">Using Base Class Pointers to Derived Class Objects</h1></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">An object of a derived class is also a member of the base class. For example, in the Polymorphic Bad Guy program, a <span class="s35">Boss </span>object is an <span class="s35">Enemy </span>object, too. That makes sense because a boss is really only a specialized kind of enemy. It also makes sense because a <span class="s35">Boss </span>object has all of the members of an <span class="s35">Enemy </span>object. Okay, so what? Well, because an object of a derived class is also a member of the base class, you can use a pointer to the base class to point to an object of the derived class. That<span class="s12">’</span>s what I do in <span class="s35">main() </span>with the following line, which instantiates a <span class="s35">Boss </span>object on the heap and creates a pointer to <span class="s35">Enemy</span>, <span class="s35">pBadGuy</span>, that points to the <span class="s35">Boss </span>object.</p><p class="s35" style="padding-top: 6pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">Enemy* pBadGuy = new Boss();</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Why in the world would you want to do this? It<span class="s12">’</span>s useful because it allows you to deal with objects without requiring that you know their exact type. For example, you could have a function that accepts a pointer to <span class="s35">Enemy </span>that could work with either an <span class="s35">Enemy </span>or a <span class="s35">Boss </span>object. The function wouldn<span class="s12">’</span>t have to know the exact type of object being passed to it; it could work with the object to produce different results depending on the object<span class="s12">’</span>s type, as long as derived member functions were declared virtual. Because <span class="s35">Attack() </span>is virtual, the correct version of the member function will be called (based on the type of object) and will not be fixed by the type of pointer.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">I prove that the behavior will be polymorphic in <span class="s35">main(). </span>Remember that <span class="s35">pBadGuy </span>is a pointer to <span class="s35">Enemy </span>that points to a <span class="s35">Boss </span>object. So, the following line calls the <span class="s35">Attack() </span>member function of a <span class="s35">Boss </span>object through a pointer to <span class="s35">Enemy</span>, which correctly results in the <span class="s35">Attack() </span>member function defined in <span class="s35">Boss </span>being</p><p class="s19" style="padding-top: 2pt;padding-left: 308pt;text-indent: 0pt;text-align: left;"><a name="bookmark1184">Introducing Polymorphism 351</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">called and the text <span class="s35">A boss attacks and inflicts 30 damage points. </span>being displayed on the screen.</p><p class="s35" style="padding-top: 5pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">pBadGuy-&gt;Attack();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s24" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Hin t</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="517" height="1" alt="image" src="Image_435.png"/></span></p><p class="s19" style="padding-top: 5pt;padding-bottom: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">Virtual functions produce polymorphic behavior through references as well as through pointers.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="498" height="3" alt="image" src="Image_436.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s24" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Tra p</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="519" height="1" alt="image" src="Image_437.png"/></span></p><p class="s19" style="padding-top: 5pt;padding-bottom: 3pt;padding-left: 59pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1123">If you override a non-virtual member function in a derived class and call that member function on a derived class object through a pointer to a base class, you’ll get the results of the base class member function and not the derived class member function definition. This is easier to understand with an example. If in the Polymorphic Bad Guy program I hadn’t declared </a><span class="s35">Attack() </span>as virtual, then when I invoked the member function through a pointer to <span class="s35">Enemy </span>on a <span class="s35">Boss </span>object with <span class="s35">pBadGuy-&gt;Attack();</span>, I would have gotten the message <span class="s35">An enemy attacks and inflicts 10 damage points. </span>This would have happened as a result of <i>early binding</i>, in which the exact member function is bound based on the pointer type—in this case, <span class="s35">Enemy</span>. But because <span class="s35">Attack() </span>is declared as virtual, the member function call is based on the type of object being pointed to at run time, <span class="s35">Boss </span>in this case, not fixed by pointer type. I achieve this polymorphic behavior as the result of <i>late binding </i>because <span class="s35">Attack() </span>is virtual. The moral of the story is that you should only override virtual member functions.<a name="bookmark1185">&zwnj;</a></p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="498" height="3" alt="image" src="Image_438.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s24" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Tra p</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="517" height="1" alt="image" src="Image_439.png"/></span></p><p class="s19" style="padding-top: 5pt;padding-bottom: 3pt;padding-left: 59pt;text-indent: 0pt;text-align: justify;">The benefits of virtual functions aren’t free; there is a performance cost associated with the overhead. Therefore, you should use virtual functions only when you need them.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="498" height="3" alt="image" src="Image_440.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part405.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part407.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
