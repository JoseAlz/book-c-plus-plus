<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Overloading the Assignment Operator</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part373.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part375.htm">Next &gt;</a></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"><h1 href="#bookmark12">Overloading the Assignment Operator</h1></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">When both sides of an assignment statement are objects of the same class, the class<span class="s12">’ </span>assignment operator member function is called. Like a default copy constructor, a default assignment operator member function is supplied for you if you don<span class="s12">’</span>t write one of your own. Also like the default copy constructor, the default assignment operator provides only member-wise duplication.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">For simple classes, the default assignment operator is usually fine. However, when you have a class with a data member that points to a value on the heap, you should consider writing an overloaded assignment operator of your own. If you don<span class="s12">’</span>t, you<span class="s12">’</span>ll end up with shallow copies of objects when you assign one object to another. To avoid this problem, I overloaded the assignment operator for <span class="s35">Critter</span>. First, inside the class definition, I write the declaration:</p><p class="s35" style="padding-top: 5pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">Critter&amp; Critter::operator=(const Critter&amp; c); //overloaded assignment</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">op</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Next, outside the class definition, I write the member function definition:</p><p class="s35" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Critter&amp; Critter::operator=(const Critter&amp; c)    //overloaded assignment op def</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;line-height: 119%;text-align: left;">cout &lt;&lt; &quot;Overloaded Assignment Operator called\n&quot;; if (this != &amp;c)</p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">delete m_pName;</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;line-height: 119%;text-align: left;">m_pName = new string(*(c.m_pName)); m_Age = c.m_Age;</p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">return *this;</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Notice that the member function returns a reference to a <span class="s35">Critter </span>object. For robust assignment operation, return a reference from the overloaded assignment operator member function.</p><p class="s19" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">314 Chapter 9 <span class="s32">n </span>Advanced Classes and Dynamic Memory: Game Lobby</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">In <span class="s35">main()</span>, I call a function that tests the overloaded assignment operator for this class.</p><p class="s35" style="padding-top: 5pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">testAssignmentOp();</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">The <span class="s35">testAssignmentOp() </span>creates two objects and assigns one to the other.</p><p class="s35" style="padding-top: 6pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">Critter crit1(&quot;crit1&quot;, 7);</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;line-height: 119%;text-align: left;">Critter crit2(&quot;crit2&quot;, 9); crit1 = crit2;</p><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">The preceding assignment statement, <span class="s35">crit1 = crit2;</span>, calls the assignment operator member function<span class="s12">—</span><span class="s35">operator=()</span><span class="s12">—</span>for <span class="s35">crit1</span>. In the <span class="s35">operator=() </span>func- tion, <span class="s35">c </span>is a constant reference to <span class="s35">crit2</span>. The goal of the member function is to assign the values of all of the data members of <span class="s35">crit2 </span>to <span class="s35">crit1 </span>while making sure each <span class="s35">Critter </span>object has its own chunks of memory on the heap for any pointer data members.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">After <span class="s35">operator=() </span>displays a message that the overloaded assignment operator has been called, it uses the <span class="s35">this </span>pointer. What<span class="s12">’</span>s the <span class="s35">this </span>pointer? It<span class="s12">’</span>s a pointer that all non-static member functions automatically have, which points to the object that was used to call the function. In this case, <span class="s35">this </span>points to <span class="s35">crit1</span>, the object being assigned to.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">The next line, <span class="s35">if (this != &amp;c)</span>, checks to see whether the address of <span class="s35">crit1 </span>is not equal to the address of <span class="s35">crit2</span><span class="s12">—</span>that is, it tests if the object isn<span class="s12">’</span>t being assigned to itself. Because it<span class="s12">’</span>s not, the block associated with the <span class="s35">if  </span>statement executes.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Inside the <span class="s35">if </span>block, <span class="s35">delete m_pName; </span>frees the memory on the heap that <span class="s35">crit1</span><span class="s12">’</span>s <span class="s35">m_pName  </span>data member pointed to. The line <span class="s35">m_pName = new string(*(c.m_pName)); </span>allocates a new chunk of memory on the heap, gets a copy of the <span class="s35">string </span>pointed to by the <span class="s35">m_pName  </span>data member of <span class="s35">crit2</span>, copies the <span class="s35">string  </span>object to the new heap memory,  and  points  the  <span class="s35">m_pName  </span>data  member  of  <span class="s35">crit1  </span>to  this  memory.  You should follow this logic for all data members that point to memory on the heap.</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">The last line in the block, <span class="s35">m_Age = c.m_Age; </span>simply copies the value of the <span class="s35">crit2</span><span class="s12">’</span>s <span class="s35">m_Age  </span>to  <span class="s35">crit1</span><span class="s12">’</span>s  <span class="s35">m_Age  </span>data  member.  You  should  follow  this  simple  member- wise copying for all data members that are not pointers to memory on the heap.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Finally, the member function returns a copy of the new <span class="s35">crit1 </span>by returning</p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">*this<span class="p">. You should do the same for any overloaded assignment operator member function you write.</span></p><p class="s19" style="padding-top: 2pt;padding-left: 252pt;text-indent: 0pt;text-align: left;"><a name="bookmark1080">Introducing the Game Lobby Program 315</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Back  in  <span class="s35">testAssignmentOp()</span>,  I  prove  that  the  assignment  worked  by  calling <span class="s35">crit1.Greet() </span>and <span class="s35">crit2.Greet()</span>. <span class="s35">crit1 </span>displays the message <span class="s35">I’m crit2 and I’m 9 years old. &amp;m_pName: 73F2ED48003AF644  </span>while <span class="s35">crit2  </span>displays the message <span class="s35">I’m crit2 and I’m 9 years old. &amp;m_pName: 73F2ED48003AF634</span>. The  first part  of  each message, <span class="s35">I’m crit2 and I’m 9 years old.</span>, is the same and shows that the copying of values worked. The second part of each message is different and shows that each object points to different chunks of memory on the heap, which demon- strates that I avoided shallow copies and have truly independent objects after the assignment.</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;"><a name="bookmark1025">In the last test of the overloaded assignment operator, I demonstrate what happens when you assign an object to itself. That</a><span class="s12">’</span>s what I do next in the function with the following lines:<a name="bookmark1081">&zwnj;</a></p><p class="s35" style="padding-top: 5pt;padding-left: 62pt;text-indent: 0pt;line-height: 118%;text-align: left;">Critter crit3(&quot;crit&quot;, 11); crit3 = crit3;</p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">The preceding assignment statement, <span class="s35">crit3 = crit3;</span>, calls the assignment operator member function<span class="s12">—</span><span class="s35">operator=()</span><span class="s12">—</span>for <span class="s35">crit3</span>. The <span class="s35">if </span>statement checks to see whether <span class="s35">crit3 </span>is being assigned to itself. Because it is, the member function simply returns a reference to the object through <span class="s35">return *this</span>. You should follow this logic in your own overloaded assignment operator because of potential problems that can arise from only one object being involved in an assignment.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s24" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Hin t</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="525" height="1" alt="image" src="Image_367.png"/></span></p><p class="s19" style="padding-top: 5pt;padding-bottom: 3pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">When you have a class with a data member that points to memory on the heap, you should consider overloading the assignment operator for the class.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="498" height="3" alt="image" src="Image_368.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part373.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part375.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
