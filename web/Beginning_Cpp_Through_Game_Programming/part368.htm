<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Avoiding Memory Leaks</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part367.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part369.htm">Next &gt;</a></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"><h1 href="#bookmark11">Avoiding Memory Leaks</h1></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">One problem with allowing a programmer to allocate and free memory is that he might allocate memory and lose any way to get at it, thus losing any way to ever free it. When memory is lost like this, it<span class="s12">’</span>s called a <span class="s11">memory leak</span>. Given a large enough leak, a program might run out of memory and crash. As a game programmer, it<span class="s12">’</span>s your responsibility to avoid memory leaks.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">I<span class="s12">’</span>ve written two functions in the Heap program that purposely create memory leaks in order to show you what <span class="s11">not </span>to do when using dynamic memory. The first function is <span class="s35">leak1()</span>, which simply allocates a chunk of memory on the heap for an <span class="s35">int </span>value and then ends.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">void leak1()</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">int* drip1 = new int(30);</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p class="s19" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">302 Chapter 9 <span class="s32">n </span>Advanced Classes and Dynamic Memory: Game Lobby</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">If I were to call this function, memory would be lost forever. (Okay, it would be lost until the program ended.) The problem is that <span class="s35">drip1</span>, which is the only connection to the newly acquired chunk of memory on the heap, is a local variable and ceases to exist when the function <span class="s35">leak1() </span>ends. So, there<span class="s12">’</span>s no way to free the allocated memory. Take a look at Figure 9.4 for a visual representa- tion of how the leak occurs.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span><img width="27" height="12" alt="image" src="Image_347.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"><span><img width="221" height="40" alt="image" src="Image_348.png"/></span></p><p class="s37" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Figure 9.4</p><p class="s19" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">The memory that stores <span class="s35">30 </span>can no longer be accessed to be freed, so it has leaked out of the system.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">To avoid this memory leak, I could do one of two things. I could use <span class="s35">delete </span>to free the memory in <span class="s35">leak1()</span>, or I could return a copy of the pointer <span class="s35">drip1</span>. If I choose the second option, I have to make sure to free this memory in some other part of the program.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">The second function that creates a memory leak is <span class="s35">leak2()</span>.</p><p class="s35" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">void leak2()</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;line-height: 118%;text-align: left;">int* drip2 = new int(50); drip2 = new int(100); delete drip2;</p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">This memory leak is a little more subtle, but there is still a leak. The first line in the function body, <span class="s35">int* drip2 = new int(50);</span>, allocates a new piece of memory on the heap, assigns <span class="s35">50 </span>to it, and has <span class="s35">drip2 </span>point to that piece memory. So far, so good. The second line, <span class="s35">drip2 = new int(100);</span>, points <span class="s35">drip2 </span>to a new piece of memory on the heap, which stores the <span class="s35">100</span>. The problem is that the memory on the heap that stores <span class="s35">50 </span>now has nothing pointing to it, so there is no way for the program to free that memory. As a result, that piece of memory has essentially leaked out of the system. Check out Figure 9.5 for a visual representation of how the leak occurs.</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">The last statement of the function, <span class="s35">delete drip2;</span>, frees the memory that stores</p><p style="padding-left: 41pt;text-indent: 0pt;text-align: justify;"><span class="s35">100</span>, so this won<span class="s12">’</span>t be the source of another memory leak. But remember, the</p><p class="s19" style="padding-top: 2pt;padding-left: 225pt;text-indent: 0pt;text-align: left;"><a name="bookmark1019">Working with Data Members and the Heap 303</a><a name="bookmark1065">&zwnj;</a><a name="bookmark1066">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="29" height="12" alt="image" src="Image_349.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="220" height="115" alt="image" src="Image_350.png"/></span></p><p class="s37" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Figure 9.5</p><p class="s19" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">By changing <span class="s35">drip2 </span>so that it points to the memory that stores <span class="s35">100</span>, the memory that stores <span class="s35">50 </span>is no longer accessible and has leaked out of the system.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;"><a name="bookmark1020">memory on the heap that stores </a><span class="s35">50 </span>has still leaked out of the system. Also, I don<span class="s12">’</span>t worry about <span class="s35">drip2</span>, which technically has become a dangling pointer, because it will cease to exist when the function ends.<a name="bookmark1067">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part367.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part369.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
