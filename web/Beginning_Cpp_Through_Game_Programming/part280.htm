<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>The winner() Function</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part279.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part281.htm">Next &gt;</a></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: justify;"><h1 href="#bookmark9">The winner() Function</h1></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">This function receives a board and returns the winner. There are four possible values for a winner. The function will return either <span class="s35">X </span>or <span class="s35">O </span>if one of the players has won. If every square is filled and no one has won, it returns <span class="s35">TIE</span>. Finally, if no one has won and there is at least one empty square, the function returns <span class="s35">NO_ONE</span>.</p><p class="s35" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">char winner(const vector&lt;char&gt;&amp; board)</p><p class="s35" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">// all possible winning rows</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">const int WINNING_ROWS[8][3] = { {0, 1, 2},</p><p class="s35" style="padding-top: 2pt;padding-left: 223pt;text-indent: 0pt;text-align: left;">{3, 4, 5},</p><p class="s35" style="padding-top: 2pt;padding-left: 223pt;text-indent: 0pt;text-align: left;">{6, 7, 8},</p><p class="s35" style="padding-top: 2pt;padding-left: 223pt;text-indent: 0pt;text-align: left;">{0, 3, 6},</p><p class="s35" style="padding-top: 2pt;padding-left: 223pt;text-indent: 0pt;text-align: left;">{1, 4, 7},</p><p class="s35" style="padding-top: 2pt;padding-left: 223pt;text-indent: 0pt;text-align: left;">{2, 5, 8},</p><p class="s35" style="padding-top: 2pt;padding-left: 223pt;text-indent: 0pt;text-align: left;">{0, 4, 8},</p><p class="s35" style="padding-top: 2pt;padding-left: 223pt;text-indent: 0pt;text-align: left;">{2, 4, 6} };</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">The first thing to notice is that the vector that represents the board is passed through a constant reference. This means that the vector is passed efficiently; it is not copied. It also means that the vector is safeguarded against any change.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">In this initial section of the function, I define a constant, two-dimensional array of <span class="s35">int</span>s called <span class="s35">WINNING_ROWS</span>, which represents all eight ways to get three in a row and  win  the  game.  Each  winning  row  is  represented  by  a  group  of  three numbers<span class="s12">—</span>three  board  positions  that  form  a  winning  row.  For  example,  the group <span class="s35">{0, 1, 2}  </span>represents the top row<span class="s12">—</span>board positions 0, 1, and 2. The next</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">group, <span class="s35">{3, 4, 5}</span>, represents the middle row<span class="s12">—</span>board positions 3, 4, and 5. And so on<span class="s51">... </span>.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Next I check to see whether either player has won.</p><p class="s19" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark790">212 Chapter 6 </a><span class="s32">n </span>References: Tic-Tac-Toe</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;text-align: left;">const int TOTAL_ROWS = 8;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;text-align: left;">// if any winning row has three values that are the same (and not EMPTY),</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">// then we have a winner</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">for(int row = 0; row &lt; TOTAL_ROWS; ++row)</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 108pt;text-indent: -26pt;line-height: 119%;text-align: left;">if ( (board[WINNING_ROWS[row][0]] != EMPTY) &amp;&amp; (board[WINNING_ROWS[row][0]] == board[WINNING_ROWS[row][1]]) &amp;&amp; (board[WINNING_ROWS[row][1]] == board[WINNING_ROWS[row][2]]) )</p><p class="s35" style="padding-left: 82pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;"><a name="bookmark724">return board[WINNING_ROWS[row][0]];</a><a name="bookmark791">&zwnj;</a></p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">I loop through each possible way a player can win to see whether either player has three in a row. The <span class="s35">if </span>statement checks to see whether the three squares in question all contain the same value and are not <span class="s35">EMPTY</span>. If so, it means that the row has either three Xs or Os in it, and one side has won. The function then returns the piece in the first position of this winning row.</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">If neither player has won, I check for a tie game.</p><p class="s35" style="padding-top: 6pt;padding-left: 62pt;text-indent: 0pt;line-height: 119%;text-align: left;">// since nobody has won, check for a tie (no empty squares left) if (count(board.begin(), board.end(), EMPTY) == 0)</p><p class="s35" style="padding-left: 82pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return TIE;</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">If there are no empty squares on the board, then the game is a tie. I use the STL <span class="s35">count() </span>algorithm, which counts the number of times a given value appears in a group of container elements, to count the number of <span class="s35">EMPTY </span>elements in <span class="s35">board</span>. If the number is equal to <span class="s35">0</span>, the function returns <span class="s35">TIE</span>.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Finally, if neither player has won and the game isn<span class="s12">’</span>t a tie, then there is no winner yet. Thus, the function returns <span class="s35">NO_ONE</span>.</p><p class="s35" style="padding-top: 5pt;padding-left: 62pt;text-indent: 0pt;line-height: 118%;text-align: left;">// since nobody has won and it isn’t a tie, the game ain’t over return NO_ONE;</p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part279.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part281.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
