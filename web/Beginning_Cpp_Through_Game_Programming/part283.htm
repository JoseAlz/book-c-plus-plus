<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>The computerMove() Function</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part282.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part284.htm">Next &gt;</a></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: justify;"><h1 href="#bookmark9">The computerMove() Function</h1></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">This function receives the board and the computer<span class="s12">’</span>s piece. It returns the computer<span class="s12">’</span>s move. The first thing to notice is that I do not pass the board by reference.</p><p class="s35" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">int computerMove(vector&lt;char&gt; board, char computer)</p><p class="s19" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">214 Chapter 6 <span class="s32">n </span>References: Tic-Tac-Toe</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Instead, I choose to pass by value, even though it<span class="s12">’</span>s not as efficient as passing by reference. I pass by value because I need to work with and modify a copy of the board as I place pieces in empty squares to determine the best computer move. By working with a copy, I keep the original vector that represents the board safe.</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Now on to the guts of the function. Okay, how do I program a bit of AI so the computer puts up a decent fight? Well, I came up with a basic three-step strategy for choosing a move.</p><p style="padding-top: 8pt;padding-left: 53pt;text-indent: 0pt;text-align: left;">1. If the computer can win on this move, make that move.</p><p style="padding-top: 5pt;padding-left: 53pt;text-indent: 0pt;text-align: left;">2. Otherwise, if the human can win on his next move, block him.</p><p style="padding-top: 5pt;padding-left: 65pt;text-indent: -11pt;line-height: 106%;text-align: left;">3. Otherwise, take the best remaining open square. The best square is the center. The next best squares are the corners, and then the rest of the squares.</p><p style="padding-top: 9pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">The next section of the function implements Step 1.</p><p class="s35" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;line-height: 118%;text-align: left;">unsigned int move = 0; bool found = false;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;line-height: 119%;text-align: left;">//if computer can win on next move, that’s the move to make while (!found &amp;&amp; move &lt; board.size())</p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">if (isLegal(move, board))</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">board[move] = computer;</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;line-height: 118%;text-align: left;">found = winner(board) == computer; board[move] = EMPTY;</p><p class="s35" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-top: 3pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">if (!found)</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">++move;</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: left;">I begin to loop through all of the possible moves, 0<span class="s12">–</span>8. For each move, I test to see whether the move is legal. If it is, I put the computer<span class="s12">’</span>s piece in the</p><p class="s19" style="padding-top: 2pt;padding-left: 272pt;text-indent: 0pt;text-align: left;">Introducing the Tic-Tac-Toe Game 215</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">corresponding square and check to see whether the move gives the computer a win. Then I undo the move by making that square empty again. If the move didn<span class="s12">’</span>t result in a win for the computer, I go on to the next empty square. However, if the move did give the computer a win, then the loop ends<span class="s12">—</span>and I<span class="s12">’</span>ve found the move (<span class="s35">found </span>is <span class="s35">true</span>) that I want the computer to make (square number <span class="s35">move</span>) to win the game.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Next, I check to see if I need to go on to Step 2 of my AI strategy. If I haven<span class="s12">’</span>t found a move yet (<span class="s35">found </span>is <span class="s35">false</span>), then I check to see whether the human can win on his next move.</p><p class="s35" style="padding-top: 5pt;padding-left: 62pt;text-indent: 0pt;line-height: 118%;text-align: left;">//otherwise, if human can win on next move, that’s the move to make if (!found)</p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">move = 0;</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">char human = opponent(computer);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">while (!found &amp;&amp; move &lt; board.size())</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">if (isLegal(move, board))</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 124pt;text-indent: 0pt;text-align: left;">board[move] = human;</p><p class="s35" style="padding-top: 2pt;padding-left: 124pt;text-indent: 0pt;line-height: 118%;text-align: left;">found = winner(board) == human; board[move] = EMPTY;</p><p class="s35" style="padding-left: 103pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-top: 3pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">if (!found)</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 124pt;text-indent: 0pt;text-align: left;">++move;</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">I begin to loop through all of the possible moves, 0<span class="s12">–</span>8. For each move, I test to see whether the move is legal. If it is, I put the human<span class="s12">’</span>s piece in the corresponding square and check to see whether the move gives the human a win. Then I undo the move by making that square empty again. If the move didn<span class="s12">’</span>t result in a win for the human, I go on to the next empty square. However, if the move did give the human a win, then the loop ends<span class="s12">—</span>and I<span class="s12">’</span>ve found the</p><p class="s19" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark795">216 Chapter 6 </a><span class="s32">n </span>References: Tic-Tac-Toe</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">move (<span class="s35">found </span>is <span class="s35">true</span>) that I want the computer to make (square number <span class="s35">move</span>) to block the human from winning on his next move.</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Next, I check to see if I need to go on to Step 3 of my AI strategy. If I haven<span class="s12">’</span>t found a move yet (<span class="s35">found </span>is <span class="s35">false</span>), then I look through the list of best moves, in order of desirability, and take the first legal one.</p><p class="s35" style="padding-top: 5pt;padding-left: 62pt;text-indent: 0pt;line-height: 119%;text-align: left;">//otherwise, moving to the best open square is the move to make if (!found)</p><p class="s35" style="padding-left: 62pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">move = 0;</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">unsigned int i = 0;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">const int BEST_MOVES[] = {4, 0, 2, 6, 8, 1, 3, 5, 7};</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">//pick best open square</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">while (!found &amp;&amp; i &lt; board.size())</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">move = BEST_MOVES[i];</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">if (isLegal(move, board))</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">{</p><p class="s35" style="padding-top: 2pt;padding-left: 124pt;text-indent: 0pt;text-align: left;">found = true;</p><p class="s35" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-top: 3pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">++i;</p><p class="s35" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">}</p><p class="s35" style="padding-top: 2pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 106%;text-align: justify;">At this point in the function, I<span class="s12">’</span>ve found the move I want the computer to make<span class="s12">—</span>whether that<span class="s12">’</span>s a move that gives the computer a win, blocks a winning move for the human, or is simply the best empty square available. So, I have the computer announce the move and return the corresponding square number.</p><p class="s35" style="padding-top: 5pt;padding-left: 62pt;text-indent: 0pt;line-height: 119%;text-align: left;">cout &lt;&lt; &quot;I shall take square number &quot; &lt;&lt; move &lt;&lt; endl; return move;</p><p class="s35" style="padding-left: 41pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s24" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Rea l Worl d</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="519" height="1" alt="image" src="Image_263.png"/></span></p><p class="s19" style="padding-top: 5pt;padding-bottom: 3pt;padding-left: 59pt;text-indent: 0pt;text-align: justify;">The Tic-Tac-Toe game considers only the next possible move. Programs that play serious games of strategy, such as chess, look far deeper into the consequences of individual moves and consider many levels of moves and countermoves. In fact, good computer chess programs can consider literally millions of board positions before making a move.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="490" height="3" alt="image" src="Image_264.png"/></span></p><p class="s19" style="padding-top: 2pt;text-indent: 0pt;text-align: right;"><a name="bookmark727">Summary 217</a><a name="bookmark796">&zwnj;</a><a name="bookmark797">&zwnj;</a><a name="bookmark798">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part282.htm">&lt; Previous</a><span> | </span><a href="../Beginning_Cpp_Through_Game_Programming.html">Contents</a><span> | </span><a href="part284.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
